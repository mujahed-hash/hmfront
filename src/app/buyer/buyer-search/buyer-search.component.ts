import { Component, OnInit, OnDestroy, Input, Output, EventEmitter, OnChanges, SimpleChanges } from '@angular/core';
import { SupplierService } from 'src/app/supplier/supplier.service';
import { LocalStorageService } from 'src/app/auth/login/local-storage.service';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { Router } from '@angular/router';
import { SharedService } from 'src/app/shared/shared.service';
import { BuyerService } from '../buyer.service';
import { FilterOptions } from '../marketplace-filter/marketplace-filter.component';
import { AuthService } from 'src/app/auth/auth.service';

interface Location {
  _id?: string; // Optional, as it might be generated by MongoDB
  city: string;
  state: string;
  cityCode: string;
  stateCode: string;
}

interface Product {
  _id: string;
  prodName: string;
  prodDesc: string;
  prodImages: string[];
  prodPrice: number;
  stock: number;
  locations: Location[]; // Updated to array of Location objects
  customIdentifier: string;
  prodSize?: string;
  inCart?: boolean;
}

interface ProductSearchResponse {
  success: boolean;
  products: Product[];
  totalProducts: number;
  hasMore: boolean;
}

@Component({
  selector: 'app-buyer-search',
  templateUrl: './buyer-search.component.html',
  styleUrls: ['./buyer-search.component.scss']
})
export class BuyerSearchComponent implements OnInit, OnDestroy, OnChanges {
  query: string = '';
  products: Product[] = [];
  start: number = 0;
  limit: number = 10;
  totalProducts: number = 0;
  searchPerformed: boolean = false;
  isLoading: boolean = false;
  token: string | null = null;
  authError: boolean = false;
  quantities: { [key: string]: number } = {};

  // Filter-related properties (received from parent)
  @Input() activeFilters: FilterOptions | null = null;
  @Input() isFiltering = false;
  @Output() searchStateChange = new EventEmitter<boolean>();
  @Output() typingStateChange = new EventEmitter<boolean>();

  hasMoreProducts = true;

  private destroy$ = new Subject<void>();

  Math = Math; // Make Math available in the template

  // View style properties
  viewStyle: 'grid' | 'compact' | 'detailed' = 'grid';
  viewStyles = [
    { value: 'grid', label: 'Grid', icon: 'grid_view' },
    // { value: 'compact', label: 'Compact', icon: 'view_comfy' },
    // { value: 'detailed', label: 'Detailed', icon: 'view_list' }
  ] as const;

  constructor(
    private supplierService: SupplierService,
    private localStorageService: LocalStorageService,
    private router: Router,
    private sharedService: SharedService,
    private buyerService: BuyerService,
    private authService: AuthService
  ) { }

  ngOnInit(): void {
    this.token = this.localStorageService.getToken();

    // Fallback to direct localStorage if service doesn't return token
    if (!this.token) {
      this.token = localStorage.getItem('token');
    }

    console.log('Search component initialized with token:', this.token ? 'Token exists' : 'No token');

    // Don't auto-show results on component load - only show when user searches
    // This ensures search results only appear when user explicitly searches
    this.loadViewStylePreference();
  }

  ngOnChanges(changes: SimpleChanges): void {
    // When activeFilters changes, reload search results only if search was performed
    if (changes['activeFilters'] && this.searchPerformed && !changes['activeFilters'].firstChange) {
      console.log('Filters changed while search active, reloading search results');
      this.start = 0;
      this.products = [];
      this.hasMoreProducts = true;
      this.totalProducts = 0;
      this.loadProducts();
    }
  }


  loadProducts(): void {
    if (this.isLoading || !this.hasMoreProducts) return;

    this.isLoading = true;

    // Always get fresh token at search time (not from stale ngOnInit value)
    this.token = localStorage.getItem('token');

    // Check if token exists
    if (!this.token) {
      this.authError = true;
      this.products = [];
      this.totalProducts = 0;
      this.isLoading = false;
      return;
    }

    // Create search filters by combining current filters with search query
    const searchFilters: FilterOptions = this.activeFilters ? { ...this.activeFilters } : {
      cities: [],
      states: [],
      categories: [],
      condition: [],
      brand: [],
      businessType: [],
      minPrice: null,
      maxPrice: null,
      sortBy: 'date',
      sortOrder: 'desc',
      search: ''
    };

    // Add search query to filters
    if (this.query.trim()) {
      searchFilters.search = this.query.trim(); // Ensure trimming here as well
    }
    console.log('Frontend searchFilters before API call:', searchFilters);

    // Always use filtered search since we want to combine search with filters
    this.buyerService.getProductsWithFilters(searchFilters, this.start, this.limit, this.token)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (response: ProductSearchResponse) => {
          console.log('Search results with filters:', response);
          this.isLoading = false;
          if (response && response.success && Array.isArray(response.products)) {
            this.products = [...this.products, ...response.products];
            this.totalProducts = response.totalProducts || this.products.length;
            this.hasMoreProducts = response.hasMore !== undefined ? response.hasMore : response.products.length === this.limit;
            this.products.forEach(product => {
              if (!this.quantities[product._id]) {
                this.quantities[product._id] = 1;
              }
            });
            this.start += this.limit;
          } else {
            console.error('Unexpected response structure:', response);
          }
        },
        error: (error) => {
          this.isLoading = false;
          console.error('Error loading search results:', error);

          // Handle specific error types
          if (error.status === 401 || error.status === 403) {
            this.authError = true;
          }

          this.products = [];
          this.totalProducts = 0;
        }
      });
  }

  onSearch(): void {
    // Only perform search if there's actual text in the input
    if (!this.query.trim()) {
      console.log('Empty search query - not performing search');
      this.searchPerformed = false;
      return;
    }

    this.searchPerformed = true;
    this.authError = false; // Reset auth error on new search

    // Unhide filters when search is executed
    this.isFocused = false;
    this.typingStateChange.emit(false);

    // Emit search state change to parent
    this.searchStateChange.emit(true);

    // Reset pagination for new search
    this.start = 0;
    this.products = [];
    this.hasMoreProducts = true;
    this.totalProducts = 0;
    this.loadProducts();
  }

  onQueryChange(newQuery: string): void {
    // Emit typing state so parent can adjust layout
    // We rely on focus/blur for hiding filters now
    // this.typingStateChange.emit(!!newQuery.trim());

    // If query becomes empty and we had search results, clear them
    if (!newQuery.trim() && this.searchPerformed) {
      console.log('Query cleared, clearing search results');
      this.searchPerformed = false;
      this.products = [];
      this.totalProducts = 0;
      this.hasMoreProducts = true;
      this.start = 0;
      this.authError = false;
      this.isLoading = false;
      // Emit search state change to parent
      this.searchStateChange.emit(false);
    }
  }

  // Native input event fallback for typing state detection
  onInputEvent(event: Event): void {
    const value = (event.target as HTMLInputElement).value;
    // We don't need to emit here if we rely on focus, but to be safe let's keep it consistent
    // or better yet, let focus/blur handle the visibility of filters
    // this.typingStateChange.emit(!!value.trim()); 
  }

  isFocused: boolean = false;

  onFocus(): void {
    this.isFocused = true;
    this.typingStateChange.emit(true);
  }

  onBlur(): void {
    this.isFocused = false;
    // Delay slightly to allow click events on search button etc
    setTimeout(() => {
      // Only emit false if we are still not focused (prevents flickering if quick re-focus)
      if (!this.isFocused) {
        this.typingStateChange.emit(false);
      }
    }, 200);
  }

  nextPage(): void {
    if (this.start + this.limit < this.totalProducts) {
      this.start += this.limit;
      this.onSearch();
    }
  }

  prevPage(): void {
    if (this.start > 0) {
      this.start -= this.limit;
      this.onSearch();
    }
  }

  loadViewStylePreference(): void {
    const savedViewStyle = localStorage.getItem('buyer-search-view-style') as 'grid' | 'compact' | 'detailed' | null;
    if (savedViewStyle && this.viewStyles.some(style => style.value === savedViewStyle)) {
      this.viewStyle = savedViewStyle;
    }
  }

  setViewStyle(style: 'grid' | 'compact' | 'detailed'): void {
    this.viewStyle = style;
    localStorage.setItem('buyer-search-view-style', style);

    this.start = 0;
    this.products = [];
    this.hasMoreProducts = true;
    this.totalProducts = 0;
    this.loadProducts();
  }

  getViewStyleClass(): string {
    return `view-${this.viewStyle}`;
  }

  addProductToCart(productId: string, quantity: number): void {
    if (!this.token) {
      this.sharedService.showNotification('Please log in to add products to cart.', 'error');
      this.router.navigate(['/login']);
      return;
    }

    if (quantity <= 0) {
      this.sharedService.showNotification('Quantity must be at least 1.', 'error');
      return;
    }

    this.buyerService.addProductToCart(productId, quantity, this.token)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (response: any) => {
          if (response && response.items) {
            this.sharedService.showNotification('Product added to cart successfully!', 'success');
            this.quantities[productId] = quantity;
            this.router.navigate(['/buyer/cart']);
          } else {
            this.sharedService.showNotification(response?.message || 'Failed to add product to cart.', 'error');
          }
        },
        error: (error: any) => {
          console.error('Error adding product to cart:', error);
          this.sharedService.showNotification('Error adding product to cart.', 'error');
        }
      });
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
